 /** Generated by the 'DATA_FETCHER_DELEGATE' default template from graphql-java-generator */
package com.huongdanjava.graphql.util;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import org.dataloader.BatchLoaderEnvironment;
import org.dataloader.DataLoader;
import org.reactivestreams.Publisher;

import com.graphql_java_generator.annotation.GraphQLDirective;
import com.graphql_java_generator.util.GraphqlUtils;

import graphql.GraphQLContext;
import graphql.schema.DataFetchingEnvironment;

/**
 * This interface contains the fata fetchers that are delegated in the bean that the implementation has to provide, when
 * fetching fields for the Query GraphQL type, as defined in the provided GraphQL schema. Please read the
 * <a href="https://github.com/graphql-java-generator/graphql-maven-plugin-project/wiki/server"> wiki server page</a>
 * for more information on this.
 *
 * @author generated by graphql-java-generator
 * @see <a href="https://github.com/graphql-java-generator/graphql-java-generator">https://github.com/graphql-java-generator/graphql-java-generator</a>
 */
@SuppressWarnings("unused")
public interface DataFetchersDelegateQuery {
	
        	/**
	 * This method loads the data for Query.students. It may return whatever is 
	 * accepted by the Spring Controller, that is:
	 * <ul>
	 * <li>A resolved value of any type (typically, a List<com.huongdanjava.graphql.Student>)</li>
	 * <li>Mono and Flux for asynchronous value(s). Supported for controller methods and for any DataFetcher as described in Reactive DataFetcher. 
	 * This would typically be a Mono&lt;List<com.huongdanjava.graphql.Student>&gt; or a Flux&lt;List<com.huongdanjava.graphql.Student>&gt;</li>
	 * <li>Kotlin coroutine and Flow are adapted to Mono and Flux</li>
	 * <li>java.util.concurrent.Callable to have the value(s) produced asynchronously. For this to work, AnnotatedControllerConfigurer must be 
	 *     configured with an Executor. This would typically by a Callable&lt;List<com.huongdanjava.graphql.Student>&gt;</li>
	 * </ul>
	 * As a complement to the spring-graphql documentation, you may also return:
	 * <ul>
	 * <li>A CompletableFuture<?>, for instance CompletableFuture<List<com.huongdanjava.graphql.Student>>. This 
	 *     allows to use <A HREF="https://github.com/graphql-java/java-dataloader">graphql-java java-dataloader</A> to highly optimize the
	 *     number of requests to the server. The principle is this one: The data loader collects all the data to load, avoid to load several 
	 *     times the same data, and allows parallel execution of the queries, if multiple queries are to be run.</li>
	 * <li>A Publisher (instead of a Flux), for Subscription for instance</li>
	 * </ul>
	 * 
	 * @param dataFetchingEnvironment 
	 *     The GraphQL {@link DataFetchingEnvironment}. It gives you access to the full GraphQL context for this DataFetcher
	 * @param clazz 
	 *     The input parameter sent in the query by the GraphQL consumer, as defined in the GraphQL schema.
	 * @throws NoSuchElementException 
	 *     This method may return a {@link NoSuchElementException} exception. In this case, the exception is trapped 
	 *     by the calling method, and the return is consider as null. This allows to use the {@link Optional#get()} method directly, without caring of 
	 *     whether or not there is a value. The generated code will take care of the {@link NoSuchElementException} exception. 
	 */
	public Object students(
			DataFetchingEnvironment dataFetchingEnvironment,
			java.lang.String clazz);

      }
